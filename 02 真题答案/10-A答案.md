[toc]

# 10年A卷参考答案

## DS

### 1 简答题

1. 栈和队列

   共同点：都是限制某一端输入输出的数据结构

   不同点：栈满足LIFO，队列满足FIFO


2. 矩阵的压缩存储：

   指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间，其目的是为了节省存储空间

   如对称矩阵，可以把矩阵的上三角和对角线元素存储在一维数组中，节约存储空间

   

### 2 判断题

这个图如果本来就是不连通的，则一次搜索是访问不到所有顶点的

在连通的情况下，如果是无向图，那么一次BFS或者DFS都能访问到所有结点，但是如果是有向图，一次可能也不行

### 3 单链表递归逆置节点

```c
typedef struct node{
    int val;
    struct node* next;
}Node,*List;

void delX(List& H,int X)
{
    Node* p;
    if(!H)return ;
    if(H->val==X)
    {
        p=H;
        H=H->next;
        delete p;
        delX(H,X);
    }
    else delX(H->next,X);
}
```

### 4 求算术表达树的值

后序遍历，遇到值入值栈，遇到操作符弹出两个值计算再压回值栈，最后栈中剩下的那个元素就是结果

```c
double func(Tree T) {
    visit(T);
    ans = ValStack.pop();
    return ans;
}

void visit(Tree T) {
    if (T) {
        visit(T->L);
        visit(T->R);
        if (T->val是数字) {
            ValStack.push(T->val);
        } else    //操作符
        {
            //num1 op num2
            num2 = ValStack.pop();
            num1 = ValStack.pop();
            switch (T->val) {
                case +:
                    ValStack.push(num1 + num2);
                    break;
                case -:
                    ValStack.push(num1 - num2);
                    break;
                case *:
                    ValStack.push(num1 * num2);
                    break;
                case /:
                    ValStack.push(num1 / num2);
                    break;
            }
        }
    }
}

```

### 5 数组按照奇偶放置

两种方法：

1. 题目不要求两种目标同时完成，假设只放置偶数，i指针指向当前的位置，如果当前位置为偶且不是偶数，那么j指针从i+1开始往后遍历找到一个偶数交换，一趟下来后i指针的位置一定全是当前数组中给的偶数（时间复杂度较高

2. i=0,j=1，i j指针同时往后走，i走到第一个不满足的位置，j走到第一个不满足的位置（两个while来控制）那么就交换它们（考试的时候不太容易想到

```c
void func1(int a[], int n) {
    //满足偶数
    //1 2 3 4 5 6
    //2 1 3 4 5 6
    //*
    //2 1 4 3 5 6
    //2 1 4 3 6 5——ok
    for (int i = 0; i < n; i += 2) {
        if (a[i] % 2 != 0) {
            int j = 1;
            while (j < n) {
                if (a[j] % 2 == 0) {
                    swap(a[i], a[j]);
                    break;
                }
                j+=2;
            }
        }
    }
}

void func2(int ary[], int n) {
    int i = 0, j = 1;
    //1 2 3 4 6 8
    //i j
    //2 1 3 4 6 8
    //    i j
    //2 1 4 3 6 8
    //        i j
    //2 1 4 3 8 6
    while (i < n && j < n) {
        while (i < n && a[i] % 2 == 0)i += 2;
        while (j < n && a[j] % 2 == 0)j += 2;
        if (i < n && j < n)swap(a[i], a[j]);
    }
}
```



## OS

### 6 名词解释

1. 进程：作业的执行过程，当用户作业需要运行时，操作系统生成PCB（进程控制块）来创建一个进程，通过执行该进程完成作业的内容，如计算，输入输出等。进程也是OS资源分配的基本单位
2. 虚拟地址：操作系统为了在逻辑上扩充物理地址，引入了缺页机制，使得进程的页不必都在内存中，从而使操作系统在逻辑上拥有更大的存储空间。访问数据时，操作系统通过将虚拟地址转换为物理地址来访问数据，如果访问的数据不在内存中，可以从外存中调入需要访问的页面。
   3. 多道程序设计：多道程序设计使得多个进程可以在同一时间段内运行，通过并发和异步的特性来保证多个进程的推进，区别于早期的单道程序设计只能由一个进程在内存中运行，大大提高了CPU利用率
4. 分时操作系统：在CPU调度中，操作系统设置固定大小的时间片，每个用户使用了一个时间片的处理器时，操作系统就会把存储当前用户的执行环境，然后切换用户，让其它用户使用处理器资源
5. **动态重定位**：在进程装入内存的时候，并不是一次性装入，而是当进程运行需要某部分数据的时候再装入内存，逻辑地址的转换是在装入内存的时候才发生的。

### 7 文件目录项，文件目录，目录文件的差别和联系

文件目录中存储着多个文件目录项，每个文件目录项对应着一个文件，有该文件的详细信息。
文件目录相当于某个目录下文件的索引表，操作系统查询文件的时候先查找文件目录中的文件目录项，根据文件目录项再去访问相应的文件。
文件目录同时也组成了一个文件，这个文件就称之为**目录文件**。

### 8 虚存的目的和作用

虚存的目的是为了从逻辑上扩充内存。虚存通过引入缺页机制和虚拟地址，使得进程运行时数据不必一直都装入内存中，当进程需要的数据不在内存中时，通过中断并调入所需页来访问此数据，中断结束后回到中断前的指令，使得进程看起来好像一直都装在内存中。

作用是扩容了内存，使得需要空间超过当前空间的进程也能在该系统中运行

### 9 两种进程调度算法

FCFS，短作业优先（平均周转时间和平均等待时间最短）

SJF：先来先服务，按照到达时间来调度，对长作业（计算型）有利，对短作业不利

优点：不会饥饿

缺点：短作业的周转时间可能很长，体验很不好 （周转时间=完成时间-到达时间）

SJF：运行时间短的作业先运行，对I/O型（短作业有利）

优点：SJF有最短的平均等待时间和平均周转时间，性能良好

缺点：会饥饿

注：

周转时间=完成时间-到达时间

平均周转时间等于周转时间求和

带权周转时间=周转时间/实际运行时间

平均带权周转时间等于带权周转时间求和

等待时间顾名思义

响应时间=从到达到第一次运行的时间



### 10 银行家算法

银行家算法是死锁避免的算法。每次资源请求的时候如果能找到一个安全序列那么就分配资源。银行家算法通过使操作系统处于安全状态来避免发生死锁（不安全状态不一定死锁，但是安全状态一定不会死锁，并且死锁一定是不安全状态）

银行家算法有

Allocation，Max，Need三个描述进程资源数的矩阵，分别是已分配资源，进程最多需要资源数，进程仍然需要的资源数。其中Max=Need+Allocation

还有Available矩阵，表示当前当前操作系统还剩余的资源。

答案：

当某个进程发出请求资源的时候

1. 判断此次请求数是否小于Need，如果超过则不分配

2. 判断请求数是否大于Available，如果大于则不分配

3. 假设满足这次资源后，执行安全性算法判断是否能找到一个安全序列使得操作系统处于安全状态，如果能找到安全序列则分配

   安全序列是指，操作系统按照这个进程请求顺序能满足所有进程的请求并且不会发生死锁


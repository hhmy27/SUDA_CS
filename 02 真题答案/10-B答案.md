[toc] 

# 10 年B卷参考答案

## DS

### 1简答题

1. 线性表：元素之间保持一对一的线性关系，此表中的存放的元素都属于同一个类型。除了第一个元素外，每个元素都有一个前驱，除了最后一个元素外，每个元素都有一个后驱

2. Dijkstra：从起始点s开始，维护一个点集S，初始只有起点s，数组d，d[i]表示s到i顶点的最短距离。初始时d设为无穷，d[s]=0。然后遍历n次，找到一个当前从距离点集S（初始只有s）距离最短的点i，将其加入点集，并且借助顶点i优化集合d，优化的条件是$d[i]+G[i][j]<d[j]$,意思是从s到i点的最短距离+i到j的距离小于之前的s到j的最短距离，则更新d[j], 执行n此后，d[i]就是起点s到i的最短距离

3.  队列的假溢现象

   队列一般使用数组来存储，经过若干次入队出队后$r==p$，此时满足队满条件，但可能还有很多空余的空间没使用

   解决的方法：

   空出一个空间：队空$r==p$，队满(r+1)%maxsize==p

   增加size标记队列中的元素个数：队空$size==0$,队满$size==maxsize$

   增加一个tag，插入时修改tag为1，出队时修改tag为0：队空$r==p且tag==0$，队满$r==p且tag==1$

### 2 同10A卷

```c
void func(Tree T, int layer) {
    if (!T)rerturn;
    func(T->L, layer + 1);
    if (T->L || T->R)cout << T << " " << layer << endl;
    func(T->R, layer + 1);
}
```

### 3 交换数组，使得数组中的0存放在表尾

```c
void func(int ary[], int n) {
    int i = 0, j = n - 1;
    while (i < n && i < j) {
        if (ary[i] == 0)
            swap(a[i], a[j--]);
        else a++;
    }
    //1 0 3 2 0 0
    //i         j
    //1 0 3 2 0 0
    //  i     j
    //1 0 3 2 0 0
    //  i   j 
    //1 2 3 0 0 0 
    //    ij
}
```

## OS

无题目
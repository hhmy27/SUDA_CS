[toc]

# 06年真题答案

## DS

### 1 名词解释

1. 堆栈：存放动态变量的区域，其中堆存放着动态分配，栈存放着局部变量

   P47T20

2. 最小生成树P211：图的最小生成树是指图的一个极小连通子图，它包含着n个结点和n-1条边，并且不构成环，并且权值最小

3. 折半查找：有序表的一种查找方法，通过取得中点比较大小来划分区域，时间复杂度为O(logn)

4. 堆排序：借用堆这种数据结构来排序。堆顶的元素一定是当前集合里面的最值，取n次最值就行了

5. **连通分量**：P183 连通分量是指图的极大连通子图，它包含该连通子图的所有边，并且子图中任意两个结点都有路径

### 2 队列模拟题

队列：

| 序列 | 123456 | 243651 | 152436 | 421356 | 126453 | 526341 |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ |
| 能否 | ✔      | ❌      | ❌      | ❌      | ❌      | ❌      |

双端队列：

| 序列 | 123456 | 243651 | 152436 | 421356 | 126453 | 526341 |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ |
| 能否 | ✔      | ✔      | ✔      | ✔      | ✔      | ❌      |

### 3 叶子节点放入表中

将二叉树的叶子节点从左到右的顺序放入一个线性表。

```c++
void func(Tree T, List &L) {
    if (!T)return;
    if (!T->L && !T->R)L.[size++] = T;
    func(T->L, L);
    func(T->R, L);
}
```

### 4 串的模式匹配

```c
int func(string str, string T, int pos) {
    int i = pos, j = 1;
    while (i <= str.size() && j <= T.size()) {
        if (str[i] = T[j]) {
            i++;
            j++;
        } else i = i - j + 2, j = 1;    //从下一个位置开始匹配
    }
    if (j > T.size())return j - T.size();    //返回匹配到的起点下标
    else return 0;    //匹配失败
}

```

### 5 递归单链表归并排序 

https://www.cnblogs.com/TenosDoIt/p/3666585.html 这个博客上写了详尽的链表排序

合并部分的代码就是两个指针依次比较，设置一个尾指针来维护排序后的链表

难的部分就是用快慢指针来取到中间节点

```c++
Node *mergeSort(List L) {
    if (!L || !L->next)return L;
    Node *slow = L->next;
    Node *fast = L->next;
    while (fast->next && fast->next->next) {
        fast = fast->next->next;
        slow = slow->next;
    }
    //至此 slow之前的是前一半链表，slow之后的是后一半链表
    //由于排序需要用空结点来作为退出条件，这里统一断开链表，然后再合并起来
    fast = slow->next;
    slow->next = NULL;
    //接下来 就分别排序好两个链表，然后将它们合并，这里写到一起了
    return merge(mergeSort(head), mergeSort(fast));
}

Node *merge(List a, List b) {
    List tHead = new Node;
    Head->next = NULL;
    Node *cur = tHead;
    while (a && b) {
        if (a->val <= b->val) {
            cur->next = a;
            a = a->next;
        } else {
            cur->next = b;
            b = b->next;
        }
        cur = cur->next;
    }
    if (a)cur->next = a;
    if (b)cur->next = b;
    return tHead->next;
}
```

补充：

单链表的快速排序

单链表的快排是基于另一种交换思想，指针i之前都小于枢纽，i之后都大于枢纽元素，用j来往后遍历，不断交换元素

```c++
Node *quickSort(List &L, int left, int right) {
    if (left < right) {
        int mid = partition(L, left, right);
        quickSort(L, left, mid - 1);
        quickSort(L, mid + 1, right);
    }
}

int partition(List &L, int left, int right) {
    Node *i = L.get(left);    //表示取得单链表的第left个结点
    Node *r = L.get(right);
    Node *j = i->next;
    int x = i->val;
    while (j != r) {
        while (j != r && j->val >= x)j = j->next;
        if (j != r) {
            i = i->next;
            swap(i->val, j->val);
            j = j->next;
        }
    }//一趟交换完成了

    swap(i->next, x);    //最后把枢纽元素交换到i结点上
    return i; //返回i结点
}
```



## OS

### 6 判断题

1. 对，并行操作需要硬件支持，单CPU只支持并发操作

   补充：

   - 并发:一个处理器同时处理多个任务。
   - 并行:多个处理器或者是多核的处理器同时处理多个不同的任务，需要硬件支持

   > 前者是逻辑上的同时发生，而后者是物理上的同时发生

2. 错，有些进程并没有资源

3. 对

### 7 解释概念

1. **中断**：中断分为内中断和外中断。内中断是指源自CPU执行指令内部的事件，如程序的非法操作码，地址越界，算术溢出，虚拟存储系统的缺页及专门的陷入指令等引发的事件。外中断是指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求，同时让完成输入/输出后的程序继续运行

2. **虚拟设备**：虚拟设备是指通过虚拟技术将一台独占设备虚拟成多台逻辑设备，供多个用户进程同时使用，通常把这种经过虚拟的设备称为虚拟设备。SPOOLing技术就是把打印机改造成虚拟设备供多个进程使用

3. 中级调度：调度的对象是进程，调度发生在内存和外存之间，当内存中的等待进程过多时，操作系统能通过中级调度把一部分进程调出外存，需要时再把进程调入内存。调出外存只是把进程映像调出外存，进程的FCB仍保留在内存中。当内存有空闲并且外村中的进程已经具备运行条件，就将它们再度调入内存，并修改其状态为就绪态，挂在就绪队列上等待

   **扩展：** 请求分页和交换有什么不同？

   交换是对整个进程进行交换，根据需要把进程从内存中移到外存，或者从外存中移入内存，CPU中的内存调度就是采取的交换技术

   请求分页调度的单位是页框，当进程运行过程中发生缺页时，操作系统发生中断并从外存中根据一定的算法把页面调入到内存

   两者的区别是交换的单位粒度不同

   联系是都涉及到内存和外存之间的调入调出

4. Cache

   Cache是介于CPU和内存之间的硬件，具有存储功能，Cache造价比内存昂贵，速度也比内存更快，由于CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。

   注：TLB（快表）其实就是一种Cache

5. LRU算法

   LRU算法是最近最久未使用调度算法，发生缺页时，此算法计算出内存中最久没被使用的页，将其换出。LRU需要寄存器和栈的硬件支持

### 8 请求分页和预调页

预调页是指根据局部性原理一次调入一批页面，而请求分页只是调入发生缺页的页面

预调页的优点是：调入的一批页面可能不久就会被访问到，减少缺页次数

缺点是：调入的一批页面可能没被访问，反而占了很多空间，造成更频繁的缺页

请求分页的优点是：稳定，安全，相比预调页有着更少的页面置换次数

缺点是：一次调入一个页面，可能会发生抖动现象

### 9 PV 

E1,E2表示空闲区，Fi表示Di发送数据

```
E1=E2=1
F1=F2=F3=0

D1(){
	P(E1)
	write data
	V(F1)
}

D2(){
	P(E2)
	write data
	V(F2)
}

D3(){
	P(E2)
	write data
	V(F3)
}

P1(){
	P(F2)
	P(F1)
	get data
	V(E1)
	V(E2)
}

P2(){
	P(F3)
	P(F1)
	get data
	V(E1)
	V(E2)
}

```

这里只可能同一时刻有P1或者P2取出数据，而此时不再有发送进程发数据，所以不用mutex

### 10 文件系统大题

文件系统大题，这里设计的目的主要是为了尽可能少的访盘，不用考虑空间和时间

假设一条记录大小为128B，则一块磁盘能放 32条记录，共32000条记录，则需要1000块磁盘块

**文件的逻辑结构采取索引文件**

**物理结构采用直接分配，支持随机访问，减少访盘次数**

**查找目录获得文件的FCB，然后将查找到的逻辑地址转换为物理地址，直接访问目标盘块即可**

共占1000个磁盘款，则平均需要访问$(1+1000)/2$个磁盘块




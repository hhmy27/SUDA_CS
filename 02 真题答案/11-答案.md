[TOC]

# 11年真题答案

## DS

### 1 简答

1. 队列是一种满足先进先出特性的线性表，只允许在表的一端插入，在另一端删除。循环队列是指为了增加空间，逻辑上把队列的尾部与首部相连，通过首尾指针的比较来判断是否队满。

   王道标准答案：P73定义，P74循环队列

2. 最小生成树是~~指图权值最小的极大连通子图~~。通过Prim或者Kruskal算法来构造

   是**权值最小的极小连通子图**

   主要强调权值最小，另外连通图是针对无向图而言的，P183

   答案：假设某张图有n个顶点，最小生成树是含有n个顶点，n-1条边，同时权值最小的子图，最小生成树的所有顶点都是连通的

   Prim思想：通过点来确定边。每次从已经确定了的点集出发，找到一个距离最近的并且加入点集后不形成环的点，然后将其加入点集，并且保存该点和点集的路径，当遍历完所有点之后，就可以确定一颗最小生成树了，适合边稠密图

   Kruskal思想：维护一个最小边集，每次都找最小边，判断它是否加入后构成环，如果不构成，就把它加入边集，并且保存该边的顶点，当遍历n-1确定n-1条边的时候，就能确定一颗最小生成树了，适合点稠密

### 2 排序

1. 长度为n的链表，n>1000，归并排序或者快排，两者平均复杂度都是$O(nlogn)$，但归并排序需要额外的$O(n)$空间，所以选择快排更好一些

2. 长度为n的数组，n>1000，同上，归并或者快排，时间复杂度$O(nlogn)$，在链表基本无序（即不会退化）的情况下快排的性能是最好的

3. 插入排序或者冒泡排序，这两者最优的时间复杂度都是$O(n)$，但是插入排序的移动次数和比较趟数更多选择**冒泡排序**

   冒泡排序执行n-1趟，碰到逆序对就交换，根据题目给的条件元素位置接近最终位置，每趟过程中碰到逆序对就交换元素会很大概率的交换到最终位置上

   注意，链表不适合希尔排序，堆排序

   注：链表排序专题：<https://www.cnblogs.com/tenosdoit/p/3666585.html>

### 3 二叉树层次遍历

```c
typedef struct node {
    int val;
    struct node *left;
    struct node *right;
} Node, *Tree;

void func(Tree T) {
    // 使用数组模拟队列，M为队列大小，考试的时候定义较大的数即可
    Node *que[M];
    int q = 0, p = 0;
    que[p++] = T;
    while (q != p) {
        int num = p - q;	// 记录当前队列中的结点数
        for (int i = 0; i < num; i++) {
            Node *t = que[q++];
            if (!t)continue;
            printf("%d ", t->val);
            que[p++] = t->left;
            que[p++] = t->right;
        }
        printf("\n");
    }
}
```

使用STL中的队列 queue 示例

```c++
typedef struct node {
    int val;
    struct node *left;
    struct node *right;
} Node, Tree;

void func(Tree T){
    queue<Node*> que;
    que.push(T);
    while(!que.empty()){
        int size = que.size();
        for (int i = 0; i < size; i++) {
        // 访问队首元素
        Node *t=que.front();
	    // 弹出队首元素
        que.pop();
        if(!t)
            continue;
        printf("%d ", t->val);
        que.push(t->left);
        que.push(t->right);
        }
        printf("\n");
    }
}
```

没用过STL的同学请不要担心，这其实和严蔚敏书上的Queue用法很相似，考试的时候是写伪码，只要你思路清晰，注释写上，改卷老师都会看懂的

### 4 拆分链表

拆分不带头结点的单链表，形成分别存放奇数结点和偶数结点的两个表

```c
typedef struct node {
    int val;
    struct node *next;
} Node, *List;

//递归版 
//其实更接近于迭代版。。A不断指向下一个节点,然后头插法就行了 
void func(List &A, List &B, List &C, int i) {
    if (!A->next)return;
    Node *p = A;
    A = A->next;
    if (i % 2 == 0) {
        p->next = B->next;
        B->next = p;
    } else {
        p->next = C->next;
        C->next = p;
    }
    func(A, B, C, i + 1);
}
```

### 5 矩阵查找

N*N的矩阵，行元素从左至右递增，列元素从上到下递增，给出O(N)的算法确定X是否在矩阵中

这种题目不容易想到，但是一知道怎么解了就记住了

```c
void func(int a[row][col], int row, int col, int x) {
    int c = col - 1;
    int r = 0;
    while (a[r][c] != x) {
        if (a[r][c] > x)
            c--;
        else r++;
    }
    cout << r << " " << c << endl;
}
```

贴一篇答案吧

<https://www.cnblogs.com/edisonchou/p/4737944.html>


## OS

### 6 判断

1. 错误，可以用虚拟技术在逻辑上扩充内存空间，进程在运行过程中不必全部存在内存中
2. 错误，假如采取预防死锁算法，如静态分配资源，可能使得系统利用率更低，为了追求效率应该尽量避免死锁发生，如采用银行家算法或者采用检测并接触死锁算法

### 7 简答

1. P36 进程和线程：

   **调度**：进程是操作系统中资源分配的最小单位，线程是操作系统中调度的最小单位。进程切换速度慢，线程切换速度快

   **从属关系**：线程依赖于进程，一个进程可以有多个线程，而一个线程只能属于一个进程

   **资源**：进程拥有操作系统分配给它的独立资源，不同进程之间的资源不共享，而线程除了少量的独立资源外，其余资源都是父进程的资源

   **并发性**：线程之间，进程之间都可以并发执行

   **通信**：不同进程之间不能直接访问资源，而同一进程下的线程可以很方便的共享资源信息。不同进程之间需要进程同步和互斥来通信，而线程不需要

   注：进程交换信息的方式

   1. 通过共享存储
      1. 基于数据结构（低级）
      2. 基于存储区（高级）
   2. 通过消息传递
      1. 直接通信
      2. 间接通信，通过信箱
   3. 通过管道

   **销毁**：当线程销毁时进程不一定销毁，而当父进程销毁时子线程一定会销毁。另外，创建和销毁进程的开销远大于创建和销毁线程的开销

2. 假如没有操作系统，程序员拿到电脑的时候就是一台裸机，需要从硬件开始写代码，完成各种文件读写，进程调度等功能，而这些功能又是通用的，操作系统的就是为开发人员提供方便的硬件和软件的集合，有了操作系统开发应用程序不必从头开始写起，在现成的操作系统上开发软件，可以利用OS已经提供好的工具更快速的开发，操作系统的诞生符合“不要重复造轮子”的思想，。。。。随便吹吹就完事了

   P4，操作系统详细的功能

   1. 管理系统资源
      1. 处理机
      2. 存储器
      3. 文件管理
   2. 提供接口
      1. 命令接口
      2. 程序接口，系统调用

### 8 自行定义一个PV操作

（除了生产者消费者问题），给出原语wait/signal来解决

理发师问题：题目略

```c
wait(P)
{
    p.value--;
    if(p.value<0)
        阻塞该进程;
}
signal(P)
{
    P.value++;
    if(P.value<=0)
        从阻塞队列中唤醒某个进程;
}
//以下用P来代替wait，V来代替signal 
semaphore mutex=1,barber=0,customer=0;
int count=n;
Barber()
{
	while(1)
    {
        P(customer);
        V(barber);
        给顾客理发；
    }
}
Customer()
{
    //这里P(mutex)一定要放在外面，否则count--等于0的时候某个进程可能仍然能进入if
    P(mutex);
    if(count)
    {
        count--;
        V(customer);
        V(mutex);
        //等待理发师
        P(barber);
        接受服务；
        P(mutex);
        count++;
        V(mutex);
        离开;
    }
    else
    {
        V(mutex);
    	离开；    
    }
}
```

### 9 介绍死锁

介绍处理死锁的策略

主要分以下三个方面：

**死锁预防**：死锁预防的策略是破坏死锁的四个必要条件

1. 破坏互斥条件：改造互斥资源为共享资源，如SPOOLing技术
2. 破坏请求并保持条件：采用静态分配资源的方法，进程一次性请求所有资源，操作系统将请求的资源分配给它
3. 破坏循环等待条件：顺序资源分配法
4. 破坏不剥夺条件：资源不足的时候可以剥夺某进程的资源进行调度死锁避免

**死锁避免**：银行家算法，总是根据当前的系统状态取分配资源，避免系统进入到可能会引起死锁的不安全状态

**死锁检测和解除**：动态分配资源，每隔一段时间按照死锁定理去简化资源分配图，如果能简化，则说明当前没有发生死锁，反之则需要解除死锁。解除死锁又有几种类型，如资源伯多发，撤销进程法，进程回退法。


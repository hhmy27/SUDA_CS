[toc]

# 07 死锁

## 测验

![7  0  0  0  年 选 （ 5 分 ） 条 统 资 源 分 酐 中 当 类 资 源 只 有 一 一 个 实 酎 ， 下 列 去 中 冫 卜 正 9 是 0  A. 死 餅 吉 点 不 一 一 定 全 在 环 中  c. 有 夕 有 环  D. 有 环 霓 啕 夕  iE 角 答 ： B 你 选 对 了 ](MdAsset/07 死锁/clip_image001.png)

辨析这道题：
A存在某个不在环中的结点，申请某个已经分配出去的资源导致自己也死锁了
有环必有死锁，有死锁必有环

![8  o  o  o  (59) ](MdAsset/07 死锁/clip_image001-1603974587217.png)

书上的定义

![10  0  0  0  选 （ 5 分 ） 下 列 选 顶 中 冖 善 于 解 除 死 祯 的 方 氵 去 是 0  A. 资 源 轨 态 岃 悝 法  B. 银 行 家 轉 法  C. 资 源 鱼 简 亻 去  D. 剥 夺 资 源 法  确 答 案 ： D 你 选 对 了 ](MdAsset/07 死锁/clip_image001-1603974597046.png)

A预防死锁，不给死锁发生的可能
B避免死锁
C检测死锁
D解除死锁

![1 1  O  判 断 （ 5 分 ） 当 檢 泌 出 发 生 死 郾 可 以 通 洹 撒 消 一 一 个 程 解 除 死 浈 ·  正 确 案 ： B 你 选 为 A  解 沂 ： 可 能 要 吓 的 多 ， 彗 程 才 能 除 死 锁 。 ](MdAsset/07 死锁/clip_image001-1603974613730.png)

![16  填 空 （ 5 分 ） 产 生 死 雹 艮 本 原 因 是 一 ， 一 一 一 一 ． 一 ， 另 一 一 个 基 本 原 因 是 讲 程 准 讲 顺 序 不 当 ．  循 娇 等 待  正 晦 案 ： 资 源 不 足  17 填 空 （ 5 分 ） 不 让 死 锁 发 生 的 策 略 可 以 分 为 静 态 和 动 态 两 种 。 死 锁 避 免 属 于  略 ·  正 晦 答 案 ： 动 态  笫  得 分 总 分  × 0 冚 5 ． 00  得 分 分  × 0 ． 0 冚 5 ． 00 ](MdAsset/07 死锁/clip_image001-1603974617830.png)

死锁预防是静态，避免是动态

![19  填 空 （ 5 分 ） 某 系 统 中 有 3 个 并 发 进 程 ， 都 需 要 同 类 资 源 4 个 ，  盗 溽 数 是  讠 亥 统 不 会 发 生 死 最 少  得 分 分  丷 5 、 00 / 5 ℃ 0  沂 ： 要 系 统 有 同 类 资 腓 个 ， 俱 n 个 讲 程 其 享 · 如 果 縋 个 讲 程 最 多 丰 清 × 个 资 源 （ 具 中 1 《 “ 《 = m ） ， 可 以 证 明 ， 当 n 伛 ． 1 廾 1 = m  时@ 系 流 不 会 发 生 死 锁 。  该 题 中 ． n=3, x=4, m > = 3 气 4 一 1 1 = 10 ](MdAsset/07 死锁/clip_image001-1603974625708.png)

![20 填 空 （ 5 分 ） 如 果 资 源 分 配 图 中 有 环 路 ， 且 每 个 资 源 类 中 只 有 一 个 资 源 ， 则 环 路 中 的 进 程  都  唱 基  正 晦 案 ： 死 锁  得 分 总 分  × 0 、 開 / 5 ℃ 0 ](MdAsset/07 死锁/clip_image001-1603974629654.png)

## 作业

![某 系 统 0 同 类 资 源 m 个 ， 供 n 个 程 共 享 · 如 果 每 个 迅 程 最 多 申 × 个 资 源 俱 中 1 < = x < = m ） ， 请  证 明 ： 当 n （ × ． 1 ） + 1 < = m 时 ， 系 统 不 会 发 生 死 浈 · ](MdAsset/07 死锁/clip_image001-1603974677108.png)

**真题考察过，重视**

**答案：**

由于每个进程最多申请使用 x 个资源，在最坏情况下，每个进程都得到了 (x-1) 个资源，并且现在都需要申请最后一个资源。此时系统剩余资源数为：m-n(x-1)。
如果系统剩余数>1，即系统还有一个资源可以使用，就可以使系统中的一个进程获得所需的全部资源，从而每个进程都可以执行完毕，然后释放出所占有的资源，供其他进程使用。
因而，当 m-n(x-1)>=1 时，即 n(x-1)+1<=m 时，系统不会发生死锁。

---

![image-20201029203922324](MdAsset/07 死锁/image-20201029203922324.png)

**答案：**

死锁：
指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程将永远不能向前推进，这种状态称为死锁。

原因：
竞争不可抢占性资源。
进程推进顺序不当。
竞争可消耗资源。

---

![image-20201029203946625](MdAsset/07 死锁/image-20201029203946625.png)

**真题考察过，重视**

**答案：**

假设max(i)表示第i个进程的最大资源需求量，need(i)表示第i个进程还需要的资源量，alloc(i)表示第i个进程已分配的资源量。根据题中条件可知：
$max(1)+...+max(n)=need(1)+...+need(n)+alloc(1)+...+alloc(n) < m+n$

说明如果这时系统发生死锁，那么这m个资源应该全部分配出去，即：

$alloc(1)+...+alloc(n) = m$

另外，系统中所有进程将陷入无限等待状态。

由上述两式可知，$need(1)+...+need(n) < n$

这表示n个进程还需要的资源量之和小于n，意味着此刻至少存在一个进程i，need(i)=0，即它已获得了所需要的全部资源。那么它就能执行完成并释放它占有的资源，这与前面的假设矛盾。从而证明在这个系统中不可能发生死锁。

---

![](MdAsset/07 死锁/clip_image001-1603975311662.png)

Need=Max-Allocation

1. Need矩阵的内容是：

P0 (0 0 0 0)

P1 (0 7 5 0)

P2 (1 0 0 2)

P3 (0 0 2 0)

P4 (0 6 4 2)

2. 存在某个安全序列that能够按此分配资源而不发生死锁就是安全状态

此时是安全的

3. 如果立刻满足P1，那么Available=1,1,0,0，可以获得P0的资源A=1，0，1，2，然后获得P3的资源，A=3，3，6，7.
             存在安全序列0,2,3,4,1可以满足哦。